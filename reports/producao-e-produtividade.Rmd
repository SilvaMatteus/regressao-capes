---
title: "Regressão linear na prática"
output:
  html_document:
    df_print: paged
    toc: yes
    toc_float: yes
    theme: readable
---

```{r warning=FALSE, echo=FALSE}
library(tidyverse)
library(broom)
library(modelr)
source(here::here("code/lib.R"))
theme_set(theme_bw())

knitr::opts_chunk$set(tidy = FALSE,
                      fig.width = 6,
                      fig.height = 5)

paleta = c("#404E4D",
           "#92DCE5",
           "#938BA1",
           "#2D3142",
           "#F4743B")
```

## Dados da CAPES sobre avaliação da pós-graduação

A CAPES é um órgão do MEC que tem a atribuição de acompanhar a pós-graduação na universidade brasileira. Uma das formas que ela encontrou de fazer isso e pela qual ela é bastante criticada é através de uma avaliação quantitativa a cada x anos (era 3, mudou para 4). 

Usaremos dados da penúltima avaliação da CAPES: 

```{r}
cacc_tudo = read_projectdata()

glimpse(cacc_tudo)
```

### Produção e produtividade de artigos

Uma das maneiras de avaliar a produção dos docentes que a CAPES utiliza é quantificando a produção de artigos pelos docentes. Os artigos são categorizados em extratos ordenados (A1 é o mais alto), e separados entre artigos em conferências e periódicos. Usaremos para esse lab a produção em periódicos avaliados com A1, A2 e B1. 

```{r}
cacc = cacc_tudo %>%
  transmute(
    docentes = `Docentes permanentes`,
    producao = (periodicos_A1 + periodicos_A2 + periodicos_B1),
    produtividade = producao / docentes,
    mestrados = Dissertacoes,
    doutorados = Teses,
    tem_doutorado = tolower(`Tem doutorado`) == "sim",
    mestrados_pprof = mestrados / docentes,
    doutorados_pprof = doutorados / docentes,
    artigos_em_conf = `Artigos em conf`,
    nivel = Nível,
    colaboradores = `Docentes colaboradores`
  )

cacc_md = cacc %>% 
  filter(tem_doutorado)
```


### EDA

```{r}
skimr::skim(cacc)
```


```{r}
cacc %>% 
  ggplot(aes(x = docentes)) + 
  geom_histogram(bins = 15, fill = paleta[1])

cacc %>% 
  ggplot(aes(x = producao)) + 
  geom_histogram(bins = 15, fill = paleta[2])

cacc %>% 
  ggplot(aes(x = produtividade)) + 
  geom_histogram(bins = 15, fill = paleta[3])
```

Se quisermos modelar o efeito do tamanho do programa em termos de docentes (permanentes) na quantidade de artigos publicados, podemos usar regressão. 

*Importante*: sempre queremos ver os dados antes de fazermos qualquer modelo ou sumário: 

```{r}
cacc %>% 
  ggplot(aes(x = docentes, y = producao)) + 
  geom_point()
```

Parece que existe uma relação. Vamos criar um modelo então:

```{r}
modelo1 = lm(producao ~ docentes, data = cacc)

tidy(modelo1, conf.int = TRUE, conf.level = 0.95)
glance(modelo1)
```

Para visualizar o modelo:

```{r}
cacc_augmented = cacc %>% 
  add_predictions(modelo1) 

cacc_augmented %>% 
  ggplot(aes(x = docentes)) + 
  geom_line(aes(y = pred), colour = "brown") + 
  geom_point(aes(y = producao)) + 
  labs(y = "Produção do programa")
```

## Mais fatores

```{r}
modelo2 = lm(producao ~ docentes + mestrados_pprof + doutorados_pprof + tem_doutorado, 
             data = cacc_md)

tidy(modelo2, conf.int = TRUE, conf.level = 0.95)
glance(modelo2)
```

E se considerarmos também o número de alunos?

```{r}
modelo2 = lm(producao ~ docentes + mestrados + doutorados, data = cacc)

tidy(modelo2, conf.int = TRUE, conf.level = 0.95)
glance(modelo2)
```

Visualizar o modelo com muitas variáveis independentes fica mais difícil

```{r}
para_plotar_modelo = cacc %>% 
  data_grid(producao = seq_range(producao, 10), # Crie um vetor de 10 valores no range
            docentes = seq_range(docentes, 4),  
            # mestrados = seq_range(mestrados, 3),
            mestrados = median(mestrados),
            doutorados = seq_range(doutorados, 3)) %>% 
  add_predictions(modelo2)

glimpse(para_plotar_modelo)

```

```{r}
para_plotar_modelo %>% 
  ggplot(aes(x = docentes, y = pred)) + 
  geom_line(aes(group = doutorados, colour = doutorados)) + 
  geom_point(data = cacc, aes(y = producao, colour = doutorados))
```

## Objetivo do lab: Medir Produtividade 

Diferente de medirmos produção (total produzido), é medirmos produtividade (produzido / utilizado). Abaixo focaremos nessa análise. Para isso crie um modelo que investiga como um conjunto de fatores que você julga que são relevantes se relacionam com a produtividade dos programas. Crie um modelo que avalie como _pelo menos 3 fatores_ se relacionam com a produtividade de um programa. Pode reutilizar fatores que já definimos e analizamos para produção. Mas cuidado para não incluir fatores que sejam função linear de outros já incluídos (ex: incluir A, B e um tercero C=A+B)

Produza abaixo o modelo e um texto que comente (i) o modelo, tal como os que fizemos antes, e (ii) as implicações - o que aprendemos sobre como funcionam programas de pós no brasil?.

## Resposta

Esconhelhos investigar como o número de docentes colaboradores, doutorados terminados e o nível de um programa se relacionam com a produtividade daquele programa.

```{r}
resp_data <- cacc %>% select(produtividade, nivel, doutorados, colaboradores)

modelo = lm(produtividade ~ doutorados + nivel + colaboradores, data = resp_data)

modelo %>%
  glance()

```

O R² obtido mostra que o nosso modelo consegue explicar apenas algo em torno de 51% da nossa variável de interesse, o que não é bom. Além disso o R² ajustado é menor ainda, indicando a presença de variáveis não relevantes para explicar a produtividade.

Vamos estudar os valores estimados para os nossos coeficientes para identificar quais são os fatores que não são relevantes.

```{r}
ic_modelo <- tidy(modelo,
                  conf.int=TRUE,
                  conf.level=0.95)
ic_modelo

ic_modelo %>%
  filter(term != "(Intercept)") %>%
  ggplot(aes(term, estimate, ymin = conf.low, ymax = conf.high)) +
  geom_errorbar(size = 0.5, width= 0.15) +
  geom_point() +
  labs(x = "Preditor",
       y = "IC do preditor com nível de confiança = 95%")
```

Podemos observar que o intervalo para o coeficiente estimado do fator número de docentes colaboradores cruza o zero, assim como o intervalo do estimado para número de doutorados terminados. Isso nos indica que esses dois fatores não são significantes.

Além disso, podemos confirmar a significância do fator nível. Acreditamos também que o fator nível é um fator relevante para prever a produtividade. O aumento de uma unidade em nível aumenta 0.78 unidades em produtividade.

Vamos plotar a reta do nosso modelo para comparar com a variável de interesse real.

```{r}
# produtividade, nivel, doutorados, colaboradores
para_plotar_modelo = resp_data %>% 
  data_grid(produtividade = seq_range(produtividade, 10), # Crie um vetor de 10 valores no range
            colaboradores = seq_range(colaboradores, 10),  
            nivel = seq_range(nivel, 5),
            doutorados = seq_range(doutorados, 10)) %>% 
  add_predictions(modelo)

glimpse(para_plotar_modelo)

para_plotar_modelo %>% 
  ggplot(aes(x = doutorados, y = pred)) + 
  geom_line(aes(group = colaboradores, colour = colaboradores)) + 
  geom_point(data = resp_data, aes(y = produtividade, colour = colaboradores)) +
  facet_wrap(~ nivel, labeller = "label_both") +
  ylab("Predição")
```

> Em geral, podemos dizer que o nosso modelo não é um bom modelo para prever produtividade. O fator Nível se mostrou o fator que mais explica a produtividade e os demais fatores não se mostraram significantes. Com esse modelo, aprendemos que o nível de um programa influencia na produtividade. Intuitivamente, pensamos que o quanto maior o nível de um programa, maior a cobrança e empenho por produtividade.